<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CyberStrike FPS</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: radial-gradient(circle at top, #0a0a1f 0%, #02020a 45%, #000 100%);
            color: #e7f5ff;
        }
        
        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 1000;
        }
        
        .crosshair-line {
            position: absolute;
            background: rgba(255, 255, 255, 0.8);
            box-shadow: 0 0 5px rgba(255, 255, 255, 0.5);
        }
        
        .horizontal {
            width: 20px;
            height: 2px;
            top: -1px;
            left: -10px;
        }
        
        .vertical {
            width: 2px;
            height: 20px;
            top: -10px;
            left: -1px;
        }
        
        #hud {
            position: absolute;
            bottom: 24px;
            left: 24px;
            display: flex;
            flex-direction: column;
            gap: 14px;
            padding: 16px 20px;
            background: rgba(10, 15, 35, 0.72);
            border: 1px solid rgba(0, 255, 170, 0.3);
            border-radius: 16px;
            backdrop-filter: blur(14px);
            box-shadow: 0 12px 32px rgba(0, 0, 0, 0.45);
            z-index: 1000;
        }

        #top-hud {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px;
            padding: 12px 28px;
            background: rgba(10, 20, 40, 0.65);
            border: 1px solid rgba(0, 255, 255, 0.3);
            border-radius: 30px;
            backdrop-filter: blur(12px);
            z-index: 1000;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.45);
        }

        .hud-card {
            display: flex;
            flex-direction: column;
            align-items: center;
            text-transform: uppercase;
            letter-spacing: 2px;
            font-size: 12px;
            color: rgba(200, 255, 255, 0.75);
        }

        .hud-card span:last-child {
            font-size: 24px;
            color: #00ffd5;
            text-shadow: 0 0 10px rgba(0, 255, 213, 0.6);
        }

        .bar-block {
            width: 260px;
        }

        .bar-header {
            display: flex;
            justify-content: space-between;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: rgba(222, 244, 255, 0.8);
            margin-bottom: 6px;
        }

        .bar-shell {
            width: 100%;
            height: 14px;
            border-radius: 999px;
            background: rgba(255, 255, 255, 0.08);
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .bar-fill {
            height: 100%;
            border-radius: 999px;
            background: linear-gradient(90deg, #ff4f6d 0%, #ff926d 100%);
            box-shadow: 0 0 12px rgba(255, 95, 109, 0.6);
            transition: width 0.2s ease-out;
        }

        .bar-fill.ammo {
            background: linear-gradient(90deg, #00d4ff 0%, #005dff 100%);
            box-shadow: 0 0 12px rgba(0, 125, 255, 0.6);
        }

        #status-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 8px;
            font-size: 13px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .status-row {
            display: flex;
            justify-content: space-between;
            background: rgba(0, 20, 35, 0.65);
            border-radius: 8px;
            padding: 8px 10px;
            border: 1px solid rgba(0, 255, 170, 0.25);
        }

        .status-banner {
            margin-top: 10px;
            text-align: center;
            padding: 10px 12px;
            border-radius: 12px;
            border: 1px solid rgba(255, 188, 80, 0.45);
            background: rgba(255, 160, 35, 0.15);
            color: #ffb347;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            box-shadow: 0 0 20px rgba(255, 170, 80, 0.3);
        }

        .status-value.active {
            color: #00ff9f;
            text-shadow: 0 0 8px rgba(0, 255, 170, 0.6);
        }

        .status-value.reloading {
            color: #ff6b6b;
            text-shadow: 0 0 8px rgba(255, 80, 80, 0.6);
        }

        #radar {
            position: absolute;
            right: 24px;
            bottom: 24px;
            width: 180px;
            height: 180px;
            border-radius: 50%;
            border: 2px solid rgba(0, 255, 200, 0.5);
            background: radial-gradient(circle, rgba(0, 40, 60, 0.75) 0%, rgba(0, 10, 20, 0.85) 65%, rgba(0, 0, 0, 0.9) 100%);
            box-shadow: 0 0 25px rgba(0, 255, 200, 0.25);
            display: none;
            z-index: 1000;
        }

        #radar.active {
            display: block;
            animation: pulse 1.2s ease-in-out infinite alternate;
        }

        @keyframes pulse {
            from { box-shadow: 0 0 18px rgba(0, 255, 200, 0.2); }
            to { box-shadow: 0 0 30px rgba(0, 255, 200, 0.5); }
        }

        #wave-alert, #medkit-alert {
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            padding: 10px 24px;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid rgba(0, 255, 213, 0.4);
            border-radius: 999px;
            text-transform: uppercase;
            letter-spacing: 2px;
            color: #00ffd5;
            font-size: 14px;
            backdrop-filter: blur(10px);
            display: none;
            z-index: 1500;
        }

        #wave-alert {
            top: 90px;
        }

        #medkit-alert {
            top: 130px;
        }

        #mode-indicator {
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            bottom: 24px;
            padding: 10px 24px;
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid rgba(0, 255, 213, 0.25);
            border-radius: 999px;
            text-transform: uppercase;
            letter-spacing: 2px;
            color: #00ffd5;
            font-size: 13px;
            backdrop-filter: blur(10px);
            z-index: 1500;
            opacity: 0.6;
        }

        #instructions {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: min(90vw, 520px);
            max-height: 95vh;
            background: radial-gradient(circle at top, rgba(10, 32, 64, 0.95) 0%, rgba(4, 10, 24, 0.95) 70%);
            border: 1px solid rgba(0, 255, 213, 0.4);
            border-radius: clamp(12px, 2vh, 24px);
            padding: clamp(16px, 3vh, 36px) clamp(20px, 4vw, 42px);
            text-align: center;
            z-index: 2000;
            box-shadow: 0 25px 80px rgba(0, 0, 0, 0.65), inset 0 0 40px rgba(0, 255, 170, 0.12);
            backdrop-filter: blur(18px);
        }

        #instructions::before {
            content: '';
            position: absolute;
            inset: clamp(6px, 1vh, 12px);
            border-radius: clamp(10px, 1.5vh, 18px);
            border: 1px dashed rgba(0, 255, 255, 0.2);
            pointer-events: none;
        }

        #instructions h1 {
            color: #00ffd5;
            margin-bottom: clamp(3px, 0.5vh, 6px);
            text-transform: uppercase;
            letter-spacing: clamp(2px, 0.6vw, 6px);
            font-size: clamp(20px, 3vh, 32px);
            text-shadow: 0 0 14px rgba(0, 255, 213, 0.7);
        }

        #instructions h3 {
            margin: 0 0 clamp(12px, 2vh, 22px);
            color: rgba(255, 255, 255, 0.8);
            font-weight: 500;
            letter-spacing: clamp(1px, 0.3vw, 3px);
            text-transform: uppercase;
            font-size: clamp(12px, 1.4vh, 16px);
        }

        #instructions p {
            font-size: clamp(11px, 1.3vh, 14px);
            line-height: 1.4;
            margin-top: clamp(12px, 1.8vh, 20px);
        }

        #instructions button {
            background: linear-gradient(120deg, #00ffd5, #0074ff);
            color: #00111f;
            border: none;
            padding: clamp(10px, 1.5vh, 14px) clamp(32px, 5vw, 48px);
            font-size: clamp(14px, 1.8vh, 18px);
            border-radius: 999px;
            cursor: pointer;
            margin-top: clamp(16px, 2.5vh, 28px);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            letter-spacing: clamp(1px, 0.2vw, 2px);
            text-transform: uppercase;
            box-shadow: 0 15px 35px rgba(0, 128, 255, 0.35);
        }

        #instructions button:hover {
            transform: translateY(-2px) scale(1.03);
            box-shadow: 0 20px 45px rgba(0, 255, 213, 0.45);
        }

        .control-item {
            margin: clamp(6px, 1vh, 12px) 0;
            text-align: left;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: clamp(6px, 1vh, 10px) clamp(10px, 1.5vw, 16px);
            border-radius: clamp(6px, 1vh, 12px);
            background: rgba(5, 16, 32, 0.85);
            border: 1px solid rgba(0, 255, 255, 0.15);
            font-size: clamp(11px, 1.4vh, 14px);
            letter-spacing: clamp(0.5px, 0.1vw, 1px);
        }

        .control-item span:last-child,
        .control-desc {
            color: rgba(255, 255, 255, 0.9);
            flex: 1;
            text-align: right;
        }

        .key {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            background: rgba(0, 255, 213, 0.15);
            padding: clamp(4px, 0.6vh, 6px) clamp(10px, 1.5vw, 14px);
            border-radius: clamp(4px, 0.8vh, 8px);
            margin-right: clamp(8px, 1vw, 12px);
            min-width: clamp(60px, 8vw, 88px);
            text-align: center;
            font-weight: 600;
            letter-spacing: clamp(0.5px, 0.1vw, 1px);
            color: #00ffd5;
            border: 1px solid rgba(0, 255, 213, 0.35);
            text-transform: uppercase;
            box-shadow: inset 0 0 10px rgba(0, 255, 170, 0.15);
        }

        #pause-menu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(2, 8, 20, 0.92);
            color: #fff;
            padding: 28px 46px;
            border-radius: 22px;
            text-align: center;
            z-index: 2000;
            display: none;
            border: 1px solid rgba(0, 136, 255, 0.4);
            box-shadow: 0 18px 60px rgba(0, 0, 0, 0.7), inset 0 0 30px rgba(0, 136, 255, 0.2);
            text-transform: uppercase;
            letter-spacing: 3px;
        }

        #pause-menu h2 {
            margin: 0 0 12px;
            color: #00b7ff;
            text-shadow: 0 0 14px rgba(0, 183, 255, 0.6);
        }

        #pause-menu p {
            margin: 0;
            color: rgba(255, 255, 255, 0.75);
            letter-spacing: 2px;
        }

        #hit-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ff0000;
            font-size: 24px;
            font-weight: bold;
            z-index: 1500;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.1s;
        }

        #damage-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, transparent 30%, rgba(255, 0, 0, 0.3) 100%);
            pointer-events: none;
            z-index: 500;
            opacity: 0;
            transition: opacity 0.2s;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="crosshair">
            <div class="crosshair-line horizontal"></div>
            <div class="crosshair-line vertical"></div>
        </div>
        <div id="top-hud">
            <div class="hud-card">
                <span>Score</span>
                <span id="score-value">0</span>
            </div>
            <div class="hud-card">
                <span>Kills</span>
                <span id="kills">0</span>
            </div>
            <div class="hud-card">
                <span>Wave</span>
                <span id="wave-value">1</span>
            </div>
        </div>
        <div id="hud">
            <div class="bar-block">
                <div class="bar-header">
                    <span>Health</span>
                    <span id="health-text">100</span>
                </div>
                <div class="bar-shell">
                    <div class="bar-fill" id="health-bar" style="width: 100%;"></div>
                </div>
            </div>
            <div class="bar-block">
                <div class="bar-header">
                    <span>Ammo</span>
                    <span id="ammo-text">30</span>
                </div>
                <div class="bar-shell">
                    <div class="bar-fill ammo" id="ammo-bar" style="width: 100%;"></div>
                </div>
            </div>
            <div id="status-grid">
                <div class="status-row">
                    <span>Fire Rate</span>
                    <span class="status-value" id="fire-rate-label">Level 1</span>
                </div>
                <div class="status-row">
                    <span>Rapid Fire</span>
                    <span class="status-value" id="rapid-fire-label">Offline</span>
                </div>
                <div class="status-row">
                    <span>Shots / Second</span>
                    <span class="status-value" id="fire-rate-stat">3.3</span>
                </div>
                <div class="status-row">
                    <span>Reload</span>
                    <span class="status-value" id="reload-indicator">Ready</span>
                </div>
            </div>
            <div id="difficulty-indicator" class="status-banner" style="display: none;">Armed Enemies Approaching!</div>
        </div>
        <canvas id="radar" width="180" height="180"></canvas>
        <div id="wave-alert"></div>
        <div id="medkit-alert"></div>
        <div id="mode-indicator">First Person</div>
        <div id="hit-indicator">HIT!</div>
        <div id="damage-overlay"></div>
        <div id="instructions">
            <h1>CyberStrike FPS</h1>
            <h3>Controls:</h3>
            <div class="control-item"><span class="key">WASD</span><span class="control-desc">Move</span></div>
            <div class="control-item"><span class="key">Mouse</span><span class="control-desc">Look Around</span></div>
            <div class="control-item"><span class="key">Click</span><span class="control-desc">Shoot</span></div>
            <div class="control-item"><span class="key">Space</span><span class="control-desc">Jump</span></div>
            <div class="control-item"><span class="key">Shift</span><span class="control-desc">Sprint</span></div>
            <div class="control-item"><span class="key">R</span><span class="control-desc">Reload</span></div>
            <div class="control-item"><span class="key">Tab</span><span class="control-desc">Toggle Third-Person View</span></div>
            <div class="control-item"><span class="key">ESC</span><span class="control-desc">Pause</span></div>
            <p style="color: #ffaa00; margin-top: 20px;">Battle through escalating waves, collect medkits to recover, and unlock radar intel after 15 kills.</p>
            <button onclick="startGame()">Click to Start</button>
        </div>
        <div id="pause-menu">
            <h2>Game Paused</h2>
            <p>Press ESC to resume</p>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let scene, camera, renderer;
        let enemies = [];
        let bullets = [];
        let enemyBullets = [];
        let particles = [];
        let medkits = [];
        let environmentAnimators = [];
        let score = 0;
        const maxHealth = 100;
        let health = maxHealth;
        const maxAmmo = 30;
        let ammo = maxAmmo;
        let kills = 0;
        let wave = 1;
        let enemiesRemainingInWave = 0;
        let waveInProgress = false;
        let waveCooldownActive = false;
        let isReloading = false;
        let clock = new THREE.Clock();
        let obstacles = [];
        const navigationGrid = {
            cellSize: 2,
            halfSize: 50,
            width: Math.floor(100 / 2),
            height: Math.floor(100 / 2),
            cells: []
        };
        const navigationTempStart = new THREE.Vector3();
        const navigationTempEnd = new THREE.Vector3();
        const navigationLine = new THREE.Line3(new THREE.Vector3(), new THREE.Vector3());
        let isMouseDown = false;
        let lastShotTime = 0;
        const baseFireRate = 300;
        const fireRateMultipliers = [1, 0.85, 0.6, 0.4];
        const fireRateShotsPerSecond = [3.3, 4.0, 5.5, 7.5];
        let rapidFireEnabled = false;
        let radarEnabled = false;
        let radarCanvas;
        let radarCtx;
        let radarDeviceRatio = 1;
        let lastDamageTime = 0;
        const healthRegenDelay = 2000;
        const healthRegenRate = 4; // per second
        let lastMedkitSpawn = 0;
        const medkitSpawnInterval = 20000;
        const maxActiveMedkits = 3;
        const medkitHealAmount = 35;
        let waveAlertTimeout;
        let medkitAlertTimeout;
        let modeIndicatorTimeout;
        
        // Game state
        let gameStarted = false;
        let gamePaused = false;
        let keys = {};
        let mouseX = 0, mouseY = 0;
        let canJump = true;
        let velocity = new THREE.Vector3();
        let direction = new THREE.Vector3();
        let moveSpeed = 15;
        let jumpSpeed = 20;
        
        // Camera rotation & perspective
        let yaw = 0;
        let pitch = 0;
        let pitchObject = new THREE.Object3D();
        let yawObject = new THREE.Object3D();
        let thirdPerson = false;
        const firstPersonCameraOffset = new THREE.Vector3(0, 0, 0);
        const thirdPersonCameraOffset = new THREE.Vector3(0.6, 0.8, 4.5);
        let cameraOffsetTarget = firstPersonCameraOffset.clone();
        let cameraCurrentOffset = firstPersonCameraOffset.clone();
        let playerModel;
        
        // Weapon state
        let weapon;
        let muzzleFlash;
        let weaponOffset = new THREE.Vector3(0.3, -0.2, -0.5);
        let weaponRecoil = 0;
        
        function init() {
            // Scene setup
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x020221, 0.018);

            // Camera setup with proper controls
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

            // Create camera control objects for proper FPS rotation
            yawObject.add(pitchObject);
            pitchObject.add(camera);
            yawObject.position.y = 1.6;
            scene.add(yawObject);

            // Renderer setup
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.setClearColor(0x03030f);
            document.getElementById('game-container').appendChild(renderer.domElement);

            radarCanvas = document.getElementById('radar');
            radarCtx = radarCanvas.getContext('2d');
            radarDeviceRatio = window.devicePixelRatio || 1;
            radarCanvas.width = radarCanvas.clientWidth * radarDeviceRatio;
            radarCanvas.height = radarCanvas.clientHeight * radarDeviceRatio;
            radarCtx.setTransform(radarDeviceRatio, 0, 0, radarDeviceRatio, 0, 0);
            lastDamageTime = Date.now();
            lastMedkitSpawn = Date.now();

            // Lighting
            const ambientLight = new THREE.AmbientLight(0x404080, 0.5);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(10, 20, 5);
            directionalLight.castShadow = true;
            directionalLight.shadow.camera.left = -50;
            directionalLight.shadow.camera.right = 50;
            directionalLight.shadow.camera.top = 50;
            directionalLight.shadow.camera.bottom = -50;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);
            
            // Point lights for atmosphere
            const pointLight1 = new THREE.PointLight(0x00ff88, 1, 30);
            pointLight1.position.set(10, 5, 10);
            scene.add(pointLight1);
            
            const pointLight2 = new THREE.PointLight(0xff0088, 1, 30);
            pointLight2.position.set(-10, 5, -10);
            scene.add(pointLight2);
            
            // Create environment
            createEnvironment();

            // Create player avatar for third-person view
            createPlayerModel();

            // Create weapon
            createWeapon();

            updateHUD();
            updateModeIndicator();

            // Event listeners
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mousedown', onMouseDown);
            document.addEventListener('mouseup', onMouseUp);
            window.addEventListener('resize', onWindowResize);
            
            // Prevent right-click context menu
            renderer.domElement.addEventListener('contextmenu', function(e) {
                e.preventDefault();
            });
        }
        
        function createEnvironment() {
            // Ground with grid texture
            const groundGeometry = new THREE.PlaneGeometry(100, 100, 50, 50);
            const groundMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x222244,
                roughness: 0.8,
                metalness: 0.2,
                wireframe: false
            });
            
            // Add vertex displacement for terrain
            const vertices = groundGeometry.attributes.position;
            for (let i = 0; i < vertices.count; i++) {
                const x = vertices.getX(i);
                const y = vertices.getY(i);
                const noise = Math.sin(x * 0.1) * Math.cos(y * 0.1) * 0.5;
                vertices.setZ(i, noise);
            }
            vertices.needsUpdate = true;
            groundGeometry.computeVertexNormals();
            
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);
            
            // Grid overlay
            const gridHelper = new THREE.GridHelper(100, 50, 0x00ff88, 0x004444);
            scene.add(gridHelper);

            const floorGlowGeometry = new THREE.PlaneGeometry(100, 100);
            const floorGlowMaterial = new THREE.MeshBasicMaterial({
                color: 0x0820a8,
                transparent: true,
                opacity: 0.18,
                side: THREE.DoubleSide
            });
            const floorGlow = new THREE.Mesh(floorGlowGeometry, floorGlowMaterial);
            floorGlow.rotation.x = -Math.PI / 2;
            floorGlow.position.y = 0.05;
            scene.add(floorGlow);
            
            // Walls and obstacles
            const wallMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x445566,
                roughness: 0.7,
                metalness: 0.3
            });
            
            // Create walls
            for (let i = 0; i < 20; i++) {
                const wallGeometry = new THREE.BoxGeometry(
                    Math.random() * 5 + 2,
                    Math.random() * 4 + 2,
                    Math.random() * 5 + 2
                );
                const wall = new THREE.Mesh(wallGeometry, wallMaterial);
                wall.position.set(
                    (Math.random() - 0.5) * 80,
                    wallGeometry.parameters.height / 2,
                    (Math.random() - 0.5) * 80
                );
                wall.castShadow = true;
                wall.receiveShadow = true;
                wall.userData.isWall = true;
                scene.add(wall);
                wall.updateMatrixWorld();
                wall.userData.boundingBox = new THREE.Box3().setFromObject(wall);
                obstacles.push(wall);
            }
            
            // Neon pillars
            const pillarGeometry = new THREE.CylinderGeometry(1, 1, 10, 8);
            const neonMaterial = new THREE.MeshStandardMaterial({
                color: 0x00ffff,
                emissive: 0x00ffff,
                emissiveIntensity: 0.5,
                roughness: 0.2,
                metalness: 0.8
            });
            
            for (let i = 0; i < 10; i++) {
                const pillar = new THREE.Mesh(pillarGeometry, neonMaterial);
                pillar.position.set(
                    (Math.random() - 0.5) * 90,
                    5,
                    (Math.random() - 0.5) * 90
                );
                pillar.castShadow = true;
                scene.add(pillar);
                pillar.updateMatrixWorld();
                pillar.userData.boundingBox = new THREE.Box3().setFromObject(pillar);
                obstacles.push(pillar);

                // Add glow
                const glowLight = new THREE.PointLight(0x00ffff, 0.5, 10);
                glowLight.position.copy(pillar.position);
                scene.add(glowLight);
            }

            buildNavigationGrid();
        }

        function buildNavigationGrid() {
            const { width, height } = navigationGrid;
            navigationGrid.cells = new Array(width);
            for (let x = 0; x < width; x++) {
                navigationGrid.cells[x] = new Array(height);
                for (let z = 0; z < height; z++) {
                    navigationGrid.cells[x][z] = 0;
                }
            }

            const padding = 0.9;
            for (const obstacle of obstacles) {
                if (!obstacle.userData || !obstacle.userData.boundingBox) continue;

                const expanded = obstacle.userData.boundingBox.clone();
                expanded.min.x -= padding;
                expanded.min.z -= padding;
                expanded.max.x += padding;
                expanded.max.z += padding;

                const minX = Math.max(0, Math.floor((expanded.min.x + navigationGrid.halfSize) / navigationGrid.cellSize));
                const minZ = Math.max(0, Math.floor((expanded.min.z + navigationGrid.halfSize) / navigationGrid.cellSize));
                const maxX = Math.min(navigationGrid.width - 1, Math.ceil((expanded.max.x + navigationGrid.halfSize) / navigationGrid.cellSize) - 1);
                const maxZ = Math.min(navigationGrid.height - 1, Math.ceil((expanded.max.z + navigationGrid.halfSize) / navigationGrid.cellSize) - 1);

                for (let gx = minX; gx <= maxX; gx++) {
                    const cellMinX = gx * navigationGrid.cellSize - navigationGrid.halfSize;
                    const cellMaxX = cellMinX + navigationGrid.cellSize;
                    for (let gz = minZ; gz <= maxZ; gz++) {
                        const cellMinZ = gz * navigationGrid.cellSize - navigationGrid.halfSize;
                        const cellMaxZ = cellMinZ + navigationGrid.cellSize;

                        if (expanded.max.x > cellMinX && expanded.min.x < cellMaxX &&
                            expanded.max.z > cellMinZ && expanded.min.z < cellMaxZ) {
                            navigationGrid.cells[gx][gz] = 1;
                        }
                    }
                }
            }
        }

        function worldToGrid(position) {
            const x = Math.floor((position.x + navigationGrid.halfSize) / navigationGrid.cellSize);
            const z = Math.floor((position.z + navigationGrid.halfSize) / navigationGrid.cellSize);
            if (Number.isNaN(x) || Number.isNaN(z)) return null;
            return {
                x: Math.max(0, Math.min(navigationGrid.width - 1, x)),
                z: Math.max(0, Math.min(navigationGrid.height - 1, z))
            };
        }

        function gridToWorld(x, z) {
            return new THREE.Vector3(
                (x + 0.5) * navigationGrid.cellSize - navigationGrid.halfSize,
                1.1,
                (z + 0.5) * navigationGrid.cellSize - navigationGrid.halfSize
            );
        }

        function isCellWalkable(x, z) {
            if (x < 0 || z < 0 || x >= navigationGrid.width || z >= navigationGrid.height) return false;
            return navigationGrid.cells[x][z] === 0;
        }

        function findNearestWalkableCell(x, z) {
            if (isCellWalkable(x, z)) {
                return { x, z };
            }

            const visited = new Set();
            const queue = [{ x, z }];
            visited.add(`${x},${z}`);
            const directions = [
                [1, 0], [-1, 0], [0, 1], [0, -1],
                [1, 1], [1, -1], [-1, 1], [-1, -1]
            ];

            while (queue.length > 0) {
                const current = queue.shift();
                for (const [dx, dz] of directions) {
                    const nx = current.x + dx;
                    const nz = current.z + dz;
                    const key = `${nx},${nz}`;
                    if (nx < 0 || nz < 0 || nx >= navigationGrid.width || nz >= navigationGrid.height) continue;
                    if (visited.has(key)) continue;
                    if (isCellWalkable(nx, nz)) {
                        return { x: nx, z: nz };
                    }
                    visited.add(key);
                    queue.push({ x: nx, z: nz });
                }
            }

            return null;
        }

        function heuristic(a, b) {
            return Math.hypot(a.x - b.x, a.z - b.z);
        }

        function findPath(startPosition, targetPosition) {
            if (!navigationGrid.cells || navigationGrid.cells.length === 0) return null;

            const startCell = worldToGrid(startPosition);
            const goalCell = worldToGrid(targetPosition);
            if (!startCell || !goalCell) return null;

            const validStart = findNearestWalkableCell(startCell.x, startCell.z);
            const validGoal = findNearestWalkableCell(goalCell.x, goalCell.z);
            if (!validStart || !validGoal) return null;

            const startKey = `${validStart.x},${validStart.z}`;
            const goalKey = `${validGoal.x},${validGoal.z}`;
            const open = [startKey];
            const openSet = new Set([startKey]);
            const cameFrom = new Map();
            const gScore = new Map([[startKey, 0]]);
            const fScore = new Map([[startKey, heuristic(validStart, validGoal)]]);

            const neighborOffsets = [
                [1, 0], [-1, 0], [0, 1], [0, -1],
                [1, 1], [1, -1], [-1, 1], [-1, -1]
            ];

            while (open.length > 0) {
                let currentIndex = 0;
                let currentKey = open[0];
                let lowestScore = fScore.get(currentKey) ?? Infinity;
                for (let i = 1; i < open.length; i++) {
                    const key = open[i];
                    const score = fScore.get(key) ?? Infinity;
                    if (score < lowestScore) {
                        lowestScore = score;
                        currentKey = key;
                        currentIndex = i;
                    }
                }

                open.splice(currentIndex, 1);
                openSet.delete(currentKey);

                if (currentKey === goalKey) {
                    return reconstructPath(cameFrom, currentKey);
                }

                const [cx, cz] = currentKey.split(',').map(Number);
                for (const [dx, dz] of neighborOffsets) {
                    const nx = cx + dx;
                    const nz = cz + dz;
                    const neighborKey = `${nx},${nz}`;

                    if (!isCellWalkable(nx, nz)) continue;

                    if (Math.abs(dx) === 1 && Math.abs(dz) === 1) {
                        if (!isCellWalkable(cx + dx, cz) || !isCellWalkable(cx, cz + dz)) {
                            continue;
                        }
                    }

                    const tentativeG = (gScore.get(currentKey) ?? Infinity) + (Math.abs(dx) === 1 && Math.abs(dz) === 1 ? Math.SQRT2 : 1);
                    const existingG = gScore.get(neighborKey);
                    if (tentativeG < (existingG ?? Infinity)) {
                        cameFrom.set(neighborKey, currentKey);
                        gScore.set(neighborKey, tentativeG);
                        const neighborCell = { x: nx, z: nz };
                        fScore.set(neighborKey, tentativeG + heuristic(neighborCell, validGoal));
                        if (!openSet.has(neighborKey)) {
                            openSet.add(neighborKey);
                            open.push(neighborKey);
                        }
                    }
                }
            }

            return null;
        }

        function reconstructPath(cameFrom, currentKey) {
            const totalPath = [currentKey];
            while (cameFrom.has(currentKey)) {
                currentKey = cameFrom.get(currentKey);
                totalPath.push(currentKey);
            }
            totalPath.reverse();

            const waypoints = [];
            for (let i = 1; i < totalPath.length; i++) {
                const [x, z] = totalPath[i].split(',').map(Number);
                waypoints.push(gridToWorld(x, z));
            }
            return waypoints;
        }

        function hasLineOfSight(start, end) {
            if (!obstacles.length) return true;

            navigationTempStart.set(start.x, 1, start.z);
            navigationTempEnd.set(end.x, 1, end.z);

            const direction = new THREE.Vector3().subVectors(navigationTempEnd, navigationTempStart);
            const distance = direction.length();
            direction.normalize();

            const ray = new THREE.Ray(navigationTempStart, direction);
            const intersectionPoint = new THREE.Vector3();

            for (const obstacle of obstacles) {
                if (!obstacle.userData || !obstacle.userData.boundingBox) continue;

                const intersection = ray.intersectBox(obstacle.userData.boundingBox, intersectionPoint);
                if (intersection) {
                    const intersectionDistance = navigationTempStart.distanceTo(intersection);
                    if (intersectionDistance <= distance) {
                        return false;
                    }
                }
            }

            return true;
        }

        function getPathDirectionForEnemy(enemy, delta) {
            if (!navigationGrid.cells || navigationGrid.cells.length === 0) return null;

            enemy.userData.pathRecalcTimer = (enemy.userData.pathRecalcTimer || 0) - delta;

            const targetCell = worldToGrid(yawObject.position);
            const targetKey = targetCell ? `${targetCell.x},${targetCell.z}` : null;

            if (!enemy.userData.path || enemy.userData.path.length === 0 || enemy.userData.pathTargetKey !== targetKey || enemy.userData.pathRecalcTimer <= 0) {
                const newPath = findPath(enemy.position, yawObject.position);
                if (newPath && newPath.length > 0) {
                    enemy.userData.path = newPath;
                    enemy.userData.pathTargetKey = targetKey;
                    enemy.userData.pathRecalcTimer = 0.35 + Math.random() * 0.25;
                } else {
                    enemy.userData.path = [];
                    enemy.userData.pathTargetKey = null;
                    enemy.userData.pathRecalcTimer = 0.2;
                }
            }

            if (!enemy.userData.path || enemy.userData.path.length === 0) {
                return null;
            }

            while (enemy.userData.path.length > 0) {
                const waypoint = enemy.userData.path[0];
                const toWaypoint = new THREE.Vector3().subVectors(waypoint, enemy.position);
                toWaypoint.y = 0;
                const distance = toWaypoint.length();
                if (distance < 0.4) {
                    enemy.userData.path.shift();
                    continue;
                }
                toWaypoint.normalize();
                return toWaypoint;
            }

            return null;
        }

        function createPlayerModel() {
            const group = new THREE.Group();

            const armorMaterial = new THREE.MeshStandardMaterial({
                color: 0x1f2aff,
                emissive: 0x0c2bff,
                emissiveIntensity: 0.6,
                metalness: 0.9,
                roughness: 0.2
            });

            const torso = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.6, 1.4, 16), armorMaterial);
            torso.position.y = 1.1;
            group.add(torso);

            const shoulderPad = new THREE.Mesh(new THREE.TorusGeometry(0.65, 0.1, 12, 32), new THREE.MeshStandardMaterial({
                color: 0x00eaff,
                emissive: 0x00eaff,
                emissiveIntensity: 0.5,
                metalness: 1,
                roughness: 0.15
            }));
            shoulderPad.position.y = 1.45;
            shoulderPad.rotation.x = Math.PI / 2;
            group.add(shoulderPad);

            const head = new THREE.Mesh(new THREE.SphereGeometry(0.35, 16, 16), new THREE.MeshStandardMaterial({
                color: 0x11132a,
                emissive: 0x0066ff,
                emissiveIntensity: 0.4,
                metalness: 0.6,
                roughness: 0.4
            }));
            head.position.y = 1.95;
            group.add(head);

            const visor = new THREE.Mesh(new THREE.TorusGeometry(0.36, 0.06, 12, 32), new THREE.MeshBasicMaterial({
                color: 0x00ffff,
                transparent: true,
                opacity: 0.6
            }));
            visor.rotation.x = Math.PI / 2;
            visor.position.y = 1.95;
            group.add(visor);

            const legsMaterial = armorMaterial.clone();
            legsMaterial.emissiveIntensity = 0.3;
            const leftLeg = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.25, 1.2, 12), legsMaterial);
            leftLeg.position.set(-0.2, 0.4, 0);
            group.add(leftLeg);
            const rightLeg = leftLeg.clone();
            rightLeg.position.x = 0.2;
            group.add(rightLeg);

            const light = new THREE.PointLight(0x1f9bff, 0.8, 6);
            light.position.set(0, 1.3, 0.3);
            group.add(light);

            group.visible = false;
            playerModel = group;
            scene.add(playerModel);
        }
        
        function createWeapon() {
            // Weapon model (simplified gun)
            const weaponGroup = new THREE.Group();
            
            // Gun body
            const bodyGeometry = new THREE.BoxGeometry(0.1, 0.1, 0.4);
            const bodyMaterial = new THREE.MeshStandardMaterial({
                color: 0x333333,
                roughness: 0.3,
                metalness: 0.8
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            weaponGroup.add(body);
            
            // Gun barrel
            const barrelGeometry = new THREE.CylinderGeometry(0.02, 0.02, 0.3);
            const barrelMaterial = new THREE.MeshStandardMaterial({
                color: 0x222222,
                roughness: 0.2,
                metalness: 0.9
            });
            const barrel = new THREE.Mesh(barrelGeometry, barrelMaterial);
            barrel.rotation.x = Math.PI / 2;
            barrel.position.z = -0.35;
            weaponGroup.add(barrel);
            
            // Sight
            const sightGeometry = new THREE.BoxGeometry(0.02, 0.04, 0.02);
            const sightMaterial = new THREE.MeshStandardMaterial({
                color: 0x00ff00,
                emissive: 0x00ff00,
                emissiveIntensity: 0.5
            });
            const sight = new THREE.Mesh(sightGeometry, sightMaterial);
            sight.position.set(0, 0.07, -0.1);
            weaponGroup.add(sight);
            
            weapon = weaponGroup;
            camera.add(weapon);
            weapon.position.copy(weaponOffset);
            
            // Muzzle flash
            const flashGeometry = new THREE.SphereGeometry(0.15, 8, 8);
            const flashMaterial = new THREE.MeshBasicMaterial({
                color: 0xffff00,
                transparent: true,
                opacity: 0
            });
            muzzleFlash = new THREE.Mesh(flashGeometry, flashMaterial);
            muzzleFlash.position.z = -0.5;
            weapon.add(muzzleFlash);
        }
        
        function createEnemy() {
            const spawnPosition = getSpawnPosition();

            const enemyGeometry = new THREE.CylinderGeometry(0.6, 0.8, 2.2, 12);
            const enemyMaterial = new THREE.MeshStandardMaterial({
                color: 0xff355a,
                emissive: 0xff2a5e,
                emissiveIntensity: 0.4,
                roughness: 0.35,
                metalness: 0.8
            });
            const enemy = new THREE.Mesh(enemyGeometry, enemyMaterial);
            enemy.castShadow = true;
            enemy.receiveShadow = true;
            enemy.position.set(spawnPosition.x, 1.1, spawnPosition.z);

            const baseHealth = 110 + (wave - 1) * 20;
            enemy.userData.maxHealth = baseHealth;
            enemy.userData.health = baseHealth;

            const speedMultiplier = 1 + (wave - 1) * 0.18 + Math.min(0.25, kills * 0.02);
            enemy.userData.speed = (Math.random() * 1.5 + 1.4) * speedMultiplier;

            enemy.userData.isArmed = kills >= 15 || wave >= 3;
            enemy.userData.lastShotTime = Date.now();
            enemy.userData.shootCooldown = Math.max(1200, 2600 - wave * 160);
            enemy.userData.hitGlow = new THREE.PointLight(0xff3355, 0.8, 6);
            enemy.userData.hitGlow.position.y = 1.2;
            enemy.add(enemy.userData.hitGlow);
            enemy.userData.path = [];
            enemy.userData.pathTargetKey = null;
            enemy.userData.pathRecalcTimer = 0;

            const visorGeometry = new THREE.TorusGeometry(0.5, 0.08, 12, 24);
            const visorMaterial = new THREE.MeshBasicMaterial({
                color: 0xfff14a,
                transparent: true,
                opacity: 0.6
            });
            const visor = new THREE.Mesh(visorGeometry, visorMaterial);
            visor.rotation.x = Math.PI / 2;
            visor.position.y = 1.4;
            enemy.add(visor);

            if (enemy.userData.isArmed) {
                const weaponGroup = new THREE.Group();
                const gunBodyGeometry = new THREE.BoxGeometry(0.05, 0.05, 0.35);
                const gunMaterial = new THREE.MeshStandardMaterial({
                    color: 0x222222,
                    roughness: 0.25,
                    metalness: 0.9
                });
                const gunBody = new THREE.Mesh(gunBodyGeometry, gunMaterial);
                weaponGroup.add(gunBody);

                const gunBarrelGeometry = new THREE.CylinderGeometry(0.01, 0.01, 0.25);
                const gunBarrel = new THREE.Mesh(gunBarrelGeometry, gunMaterial);
                gunBarrel.rotation.x = Math.PI / 2;
                gunBarrel.position.z = -0.25;
                weaponGroup.add(gunBarrel);

                weaponGroup.position.set(0.4, 0.2, 0.5);
                enemy.add(weaponGroup);
                enemy.userData.weapon = weaponGroup;
                enemy.material.color.setRGB(0.65, 0.2, 1);
                enemy.material.emissive.setRGB(0.2, 0.05, 0.4);
            }

            enemies.push(enemy);
            scene.add(enemy);
        }

        function getFireRateLevel() {
            if (kills >= 45 || wave >= 6) return 4;
            if (kills >= 35 || wave >= 5) return 3;
            if (kills >= 25 || wave >= 3) return 2;
            return 1;
        }
        
        function shoot() {
            if (!gameStarted || gamePaused || isReloading || ammo <= 0) return;

            const now = Date.now();
            const fireRateLevel = getFireRateLevel();
            const currentFireRate = baseFireRate * fireRateMultipliers[fireRateLevel - 1];
            if (now - lastShotTime < currentFireRate) return;
            lastShotTime = now;

            // Weapon recoil animation
            weaponRecoil = 0.2;

            // Muzzle flash
            muzzleFlash.material.opacity = 1;
            setTimeout(() => {
                muzzleFlash.material.opacity = 0;
            }, 50);
            
            // Create bullet
            const bulletGeometry = new THREE.SphereGeometry(0.05, 4, 4);
            const bulletMaterial = new THREE.MeshBasicMaterial({
                color: 0xffff00,
                emissive: 0xffff00
            });
            const bullet = new THREE.Mesh(bulletGeometry, bulletMaterial);
            
            // Get proper bullet direction using camera's world direction
            const bulletDirection = new THREE.Vector3();
            camera.getWorldDirection(bulletDirection);
            
            // Get camera world position
            const cameraWorldPosition = new THREE.Vector3();
            camera.getWorldPosition(cameraWorldPosition);
            
            bullet.position.copy(cameraWorldPosition);
            bullet.userData.velocity = bulletDirection.multiplyScalar(100);
            bullet.userData.life = 100;
            bullet.userData.hasHit = false;
            bullet.userData.isPlayerBullet = true;
            
            bullets.push(bullet);
            scene.add(bullet);
            
            // Create particle effect at muzzle
            createMuzzleParticles();
            
            // Update ammo
            ammo--;
            updateHUD();

            // Auto reload
            if (ammo === 0) {
                reload();
            }
        }
        
        function enemyShoot(enemy) {
            // Create enemy bullet
            const bulletGeometry = new THREE.SphereGeometry(0.04, 4, 4);
            const bulletMaterial = new THREE.MeshBasicMaterial({
                color: 0xff0044,
                emissive: 0xff0044
            });
            const bullet = new THREE.Mesh(bulletGeometry, bulletMaterial);
            
            // Calculate direction from enemy to player
            const bulletDirection = new THREE.Vector3();
            bulletDirection.subVectors(yawObject.position, enemy.position);
            bulletDirection.normalize();
            
            bullet.position.copy(enemy.position);
            bullet.position.y += 1; // Shoot from chest level
            bullet.userData.velocity = bulletDirection.multiplyScalar(80);
            bullet.userData.life = 100;
            bullet.userData.hasHit = false;
            bullet.userData.isPlayerBullet = false;
            
            enemyBullets.push(bullet);
            scene.add(bullet);
            
            // Create muzzle flash for enemy
            createEnemyMuzzleFlash(enemy);
            
            // Update enemy's last shot time
            enemy.userData.lastShotTime = Date.now();
        }
        
        function createEnemyMuzzleFlash(enemy) {
            if (enemy.userData.weapon) {
                const flashGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                const flashMaterial = new THREE.MeshBasicMaterial({
                    color: 0xff0044,
                    transparent: true,
                    opacity: 1
                });
                const flash = new THREE.Mesh(flashGeometry, flashMaterial);
                
                const weaponWorldPos = new THREE.Vector3();
                enemy.userData.weapon.getWorldPosition(weaponWorldPos);
                flash.position.copy(weaponWorldPos);
                
                scene.add(flash);
                
                setTimeout(() => {
                    scene.remove(flash);
                }, 100);
            }
        }
        
        function createMuzzleParticles() {
            for (let i = 0; i < 10; i++) {
                const particleGeometry = new THREE.SphereGeometry(0.02, 4, 4);
                const particleMaterial = new THREE.MeshBasicMaterial({
                    color: 0xffaa00,
                    transparent: true,
                    opacity: 1
                });
                const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                
                const worldPosition = new THREE.Vector3();
                weapon.localToWorld(worldPosition.copy(muzzleFlash.position));
                particle.position.copy(worldPosition);
                
                particle.userData.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 5,
                    (Math.random() - 0.5) * 5,
                    (Math.random() - 0.5) * 5
                );
                particle.userData.life = 30;
                
                particles.push(particle);
                scene.add(particle);
            }
        }
        
        function createHitParticles(position, color = 0xff0000) {
            for (let i = 0; i < 20; i++) {
                const particleGeometry = new THREE.BoxGeometry(0.1, 0.1, 0.1);
                const particleMaterial = new THREE.MeshBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: 1
                });
                const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                
                particle.position.copy(position);
                particle.userData.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 10,
                    Math.random() * 5,
                    (Math.random() - 0.5) * 10
                );
                particle.userData.life = 50;
                particle.userData.rotationSpeed = new THREE.Vector3(
                    Math.random() * 0.5,
                    Math.random() * 0.5,
                    Math.random() * 0.5
                );
                
                particles.push(particle);
                scene.add(particle);
            }
        }

        function showHitIndicator() {
            const hitIndicator = document.getElementById('hit-indicator');
            hitIndicator.style.opacity = '1';
            setTimeout(() => {
                hitIndicator.style.opacity = '0';
            }, 200);
        }

        function showDamageOverlay() {
            const damageOverlay = document.getElementById('damage-overlay');
            damageOverlay.style.opacity = '1';
            setTimeout(() => {
                damageOverlay.style.opacity = '0';
            }, 300);
        }
        
        function reload() {
            if (isReloading) return;
            isReloading = true;
            const reloadIndicator = document.getElementById('reload-indicator');
            reloadIndicator.textContent = 'Reloading...';
            reloadIndicator.classList.add('reloading');

            setTimeout(() => {
                ammo = maxAmmo;
                isReloading = false;
                reloadIndicator.textContent = 'Ready';
                reloadIndicator.classList.remove('reloading');
                updateHUD();
            }, 2000);
        }
        
        function updatePlayer(delta) {
            if (!gameStarted || gamePaused) return;

            const prevPosition = yawObject.position.clone();
            
            // Get movement direction
            direction.set(0, 0, 0);
            
            if (keys['w'] || keys['arrowup']) direction.z -= 1;
            if (keys['s'] || keys['arrowdown']) direction.z += 1;
            if (keys['a'] || keys['arrowleft']) direction.x -= 1;
            if (keys['d'] || keys['arrowright']) direction.x += 1;
            
            direction.normalize();
            
            // Apply sprint
            const currentSpeed = keys['shift'] ? moveSpeed * 1.5 : moveSpeed;
            
            // Move player relative to camera direction
            if (direction.length() > 0) {
                const moveVector = new THREE.Vector3();
                moveVector.copy(direction);
                moveVector.applyQuaternion(yawObject.quaternion);
                moveVector.y = 0;
                moveVector.normalize();
                
                yawObject.position.add(moveVector.multiplyScalar(currentSpeed * delta));
            }
            
            // Jump
            if (keys[' '] && canJump) {
                velocity.y = jumpSpeed;
                canJump = false;
            }
            
            // Apply gravity
            velocity.y -= 40 * delta;
            yawObject.position.y += velocity.y * delta;
            
            // Ground check
            if (yawObject.position.y < 1.6) {
                yawObject.position.y = 1.6;
                velocity.y = 0;
                canJump = true;
            }

            const playerBox = new THREE.Box3().setFromCenterAndSize(
                new THREE.Vector3(yawObject.position.x, yawObject.position.y, yawObject.position.z),
                new THREE.Vector3(1, 3, 1)
            );
            for (const obs of obstacles) {
                if (obs.userData.boundingBox && obs.userData.boundingBox.intersectsBox(playerBox)) {
                    yawObject.position.copy(prevPosition);
                    break;
                }
            }
            yawObject.position.x = Math.max(-49, Math.min(49, yawObject.position.x));
            yawObject.position.z = Math.max(-49, Math.min(49, yawObject.position.z));
            
            // Weapon sway
            if (weapon) {
                weapon.visible = !thirdPerson;
                if (!thirdPerson) {
                    weapon.position.x = weaponOffset.x + Math.sin(clock.elapsedTime * 2) * 0.01;
                    weapon.position.y = weaponOffset.y + Math.sin(clock.elapsedTime * 4) * 0.005;

                    // Apply recoil
                    weapon.position.z = weaponOffset.z + weaponRecoil;
                    weapon.rotation.x = weaponRecoil * 0.5;
                    weaponRecoil *= 0.9;
                }
            }

            if (playerModel) {
                playerModel.visible = thirdPerson;
                playerModel.position.set(
                    yawObject.position.x,
                    yawObject.position.y - 1.6,
                    yawObject.position.z
                );
                playerModel.rotation.y = yaw;
            }
        }
        
        function updateEnemies(delta) {
            if (!gameStarted || gamePaused) return;

            const currentTime = Date.now();

            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                const toPlayer = new THREE.Vector3().subVectors(yawObject.position, enemy.position);
                const planarToPlayer = new THREE.Vector3(toPlayer.x, 0, toPlayer.z);
                let moveDirection = null;

                if (planarToPlayer.lengthSq() > 0.000001) {
                    if (hasLineOfSight(enemy.position, yawObject.position)) {
                        enemy.userData.path = [];
                        enemy.userData.pathTargetKey = null;
                        enemy.userData.pathRecalcTimer = 0.2;
                        moveDirection = planarToPlayer.clone().normalize();
                    } else {
                        const pathDirection = getPathDirectionForEnemy(enemy, delta);
                        if (pathDirection) {
                            moveDirection = pathDirection;
                        } else {
                            moveDirection = planarToPlayer.clone().normalize();
                        }
                    }
                }

                if (moveDirection) {
                    const prevPos = enemy.position.clone();
                    enemy.position.addScaledVector(moveDirection, enemy.userData.speed * delta);

                    const enemyBox = new THREE.Box3().setFromCenterAndSize(
                        new THREE.Vector3(enemy.position.x, enemy.position.y, enemy.position.z),
                        new THREE.Vector3(1.2, 3, 1.2)
                    );
                    let collided = false;
                    for (const obs of obstacles) {
                        if (obs.userData.boundingBox && obs.userData.boundingBox.intersectsBox(enemyBox)) {
                            collided = true;
                            break;
                        }
                    }
                    if (collided) {
                        enemy.position.copy(prevPos);
                        if (enemy.userData.path && enemy.userData.path.length > 0) {
                            enemy.userData.path.shift();
                        }
                        enemy.userData.pathRecalcTimer = 0;
                    }
                }

                enemy.position.x = Math.max(-48, Math.min(48, enemy.position.x));
                enemy.position.z = Math.max(-48, Math.min(48, enemy.position.z));

                enemy.lookAt(yawObject.position.x, enemy.position.y, yawObject.position.z);

                const healthPercent = enemy.userData.health / enemy.userData.maxHealth;
                enemy.material.emissiveIntensity = 0.35 + (1 - healthPercent) * 0.45;
                if (enemy.userData.isArmed) {
                    enemy.material.color.setRGB(0.5 + 0.3 * healthPercent, 0.15, 0.75 * healthPercent);
                } else {
                    enemy.material.color.setRGB(1, 0.35 * healthPercent, 0.35 * healthPercent);
                }
                if (enemy.userData.hitGlow) {
                    enemy.userData.hitGlow.intensity = 0.6 + (1 - healthPercent) * 0.8;
                }

                const updatedPlanar = new THREE.Vector3().subVectors(yawObject.position, enemy.position);
                updatedPlanar.y = 0;
                const distanceToPlayer = updatedPlanar.length();
                let approachDirection = null;
                if (distanceToPlayer > 0.000001) {
                    approachDirection = updatedPlanar.clone().normalize();
                }

                if (enemy.userData.isArmed &&
                    currentTime - enemy.userData.lastShotTime > enemy.userData.shootCooldown) {
                    const rangedDistance = enemy.position.distanceTo(yawObject.position);
                    if (rangedDistance < 35) {
                        enemyShoot(enemy);
                    }
                }

                if (distanceToPlayer < 1.2 && approachDirection) {
                    enemy.position.addScaledVector(approachDirection, -0.5);
                }

                if (distanceToPlayer < 2.4) {
                    const damageRate = enemy.userData.isArmed ? 32 : 24;
                    health -= damageRate * delta;
                    lastDamageTime = currentTime;
                    showDamageOverlay();
                    updateHUD();

                    if (health <= 0) {
                        gameOver();
                        return;
                    }
                }

                if (enemy.userData.health <= 0) {
                    handleEnemyDefeat(enemy, i);
                }
            }
        }

        function handleEnemyDefeat(enemy, index) {
            createHitParticles(enemy.position);
            if (enemy.userData.hitGlow) {
                enemy.remove(enemy.userData.hitGlow);
            }
            scene.remove(enemy);
            enemies.splice(index, 1);

            kills++;
            enemiesRemainingInWave = Math.max(0, enemiesRemainingInWave - 1);
            score += 100 + wave * 25;
            updateHUD();

            if (kills === 15) {
                const indicator = document.getElementById('difficulty-indicator');
                indicator.style.display = 'block';
                setTimeout(() => {
                    indicator.style.display = 'none';
                }, 3000);
            }

            if (!radarEnabled && kills >= 15) {
                enableRadar('Radar Online');
            }

            if (Math.random() < 0.18) {
                spawnMedkit(enemy.position);
            }

            checkWaveStatus();
        }

        function checkWaveStatus() {
            if (!waveInProgress) return;
            if (enemiesRemainingInWave <= 0 && enemies.length === 0 && !waveCooldownActive) {
                waveInProgress = false;
                waveCooldownActive = true;
                showWaveAlert(`Wave ${wave} Cleared`);
                setTimeout(() => {
                    wave++;
                    waveCooldownActive = false;
                    startWave();
                }, 3500);
            }
        }

        function updateBullets(delta) {
            if (!gameStarted || gamePaused) return;
            
            // Update player bullets
            for (let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets[i];

                bullet.position.add(bullet.userData.velocity.clone().multiplyScalar(delta));

                if (!bullet.userData.hasHit) {
                    for (let j = 0; j < enemies.length; j++) {
                        const enemy = enemies[j];
                        const distance = bullet.position.distanceTo(enemy.position);

                        if (distance < 1.5) {
                            bullet.userData.hasHit = true;
                            enemy.userData.health -= 50;
                            showHitIndicator();
                            createHitParticles(bullet.position);
                            scene.remove(bullet);
                            bullets.splice(i, 1);
                            break;
                        }
                    }
                }

                if (bullets[i] && !bullet.userData.hasHit) {
                    for (const obs of obstacles) {
                        if (obs.userData.boundingBox && obs.userData.boundingBox.containsPoint(bullet.position)) {
                            bullet.userData.hasHit = true;
                            createHitParticles(bullet.position);
                            scene.remove(bullet);
                            bullets.splice(i, 1);
                            break;
                        }
                    }
                }

                if (bullets[i]) {
                    bullet.userData.life--;
                    if (bullet.userData.life <= 0) {
                        scene.remove(bullet);
                        bullets.splice(i, 1);
                    }
                }
            }
            
            // Update enemy bullets
            for (let i = enemyBullets.length - 1; i >= 0; i--) {
                const bullet = enemyBullets[i];

                bullet.position.add(bullet.userData.velocity.clone().multiplyScalar(delta));

                if (!bullet.userData.hasHit) {
                    const distance = bullet.position.distanceTo(yawObject.position);

                    if (distance < 1.5) {
                        bullet.userData.hasHit = true;
                        health -= 10;
                        lastDamageTime = Date.now();
                        showDamageOverlay();
                        createHitParticles(bullet.position, 0x00ff88);
                        scene.remove(bullet);
                        enemyBullets.splice(i, 1);
                        updateHUD();

                        if (health <= 0) {
                            gameOver();
                        }
                        continue;
                    }
                }

                if (enemyBullets[i] && !bullet.userData.hasHit) {
                    for (const obs of obstacles) {
                        if (obs.userData.boundingBox && obs.userData.boundingBox.containsPoint(bullet.position)) {
                            bullet.userData.hasHit = true;
                            createHitParticles(bullet.position, 0xff0044);
                            scene.remove(bullet);
                            enemyBullets.splice(i, 1);
                            break;
                        }
                    }
                }

                if (enemyBullets[i]) {
                    bullet.userData.life--;
                    if (bullet.userData.life <= 0) {
                        scene.remove(bullet);
                        enemyBullets.splice(i, 1);
                    }
                }
            }
        }
        
        function updateParticles(delta) {
            for (let i = particles.length - 1; i >= 0; i--) {
                const particle = particles[i];
                
                particle.position.add(particle.userData.velocity.clone().multiplyScalar(delta));
                particle.userData.velocity.y -= 20 * delta;
                
                if (particle.userData.rotationSpeed) {
                    particle.rotation.x += particle.userData.rotationSpeed.x;
                    particle.rotation.y += particle.userData.rotationSpeed.y;
                    particle.rotation.z += particle.userData.rotationSpeed.z;
                }
                
                particle.material.opacity = particle.userData.life / 50;
                
                particle.userData.life--;
                if (particle.userData.life <= 0) {
                    scene.remove(particle);
                    particles.splice(i, 1);
                }
            }
        }
        
        function updateHUD() {
            const clampedHealth = Math.max(0, Math.min(maxHealth, health));
            const healthPercent = clampedHealth / maxHealth;
            document.getElementById('health-bar').style.width = `${healthPercent * 100}%`;
            document.getElementById('health-text').textContent = `${Math.floor(clampedHealth)}/${maxHealth}`;

            const ammoPercent = Math.max(0, Math.min(1, ammo / maxAmmo));
            document.getElementById('ammo-bar').style.width = `${ammoPercent * 100}%`;
            document.getElementById('ammo-text').textContent = `${ammo}/${maxAmmo}`;

            document.getElementById('score-value').textContent = score;
            document.getElementById('kills').textContent = kills;
            document.getElementById('wave-value').textContent = wave;

            const fireRateLevel = getFireRateLevel();
            document.getElementById('fire-rate-label').textContent = `Level ${fireRateLevel}`;

            const multiplier = fireRateMultipliers[fireRateLevel - 1];
            const shotsPerSecond = (1000 / (baseFireRate * multiplier)).toFixed(1);
            document.getElementById('fire-rate-stat').textContent = shotsPerSecond;

            rapidFireEnabled = kills >= 25 || wave >= 4;
            const rapidFireLabel = document.getElementById('rapid-fire-label');
            rapidFireLabel.textContent = rapidFireEnabled ? 'Online' : 'Offline';
            rapidFireLabel.classList.toggle('active', rapidFireEnabled);

            if (!radarEnabled && kills >= 15) {
                enableRadar('Radar Online');
            }
        }
        
        function gameOver() {
            gameStarted = false;
            gamePaused = true;
            document.exitPointerLock();
            alert(`Game Over!\nWave Reached: ${wave}\nKills: ${kills}\nScore: ${score}`);
            location.reload();
        }
        
        function togglePause() {
            if (!gameStarted) return;
            
            gamePaused = !gamePaused;
            const pauseMenu = document.getElementById('pause-menu');
            
            if (gamePaused) {
                pauseMenu.style.display = 'block';
                document.exitPointerLock();
            } else {
                pauseMenu.style.display = 'none';
                renderer.domElement.requestPointerLock();
            }
        }

        function updateShooting() {
            if (!gameStarted || gamePaused) return;
            if (isMouseDown && rapidFireEnabled) {
                shoot();
            }
        }

        function togglePerspective() {
            thirdPerson = !thirdPerson;
            cameraOffsetTarget.copy(thirdPerson ? thirdPersonCameraOffset : firstPersonCameraOffset);
            if (!thirdPerson) {
                cameraCurrentOffset.copy(firstPersonCameraOffset);
            }
            updateModeIndicator();
        }

        function updateModeIndicator() {
            const indicator = document.getElementById('mode-indicator');
            indicator.textContent = thirdPerson ? 'Third Person' : 'First Person';
            indicator.style.opacity = '1';
            if (modeIndicatorTimeout) {
                clearTimeout(modeIndicatorTimeout);
            }
            modeIndicatorTimeout = setTimeout(() => {
                indicator.style.opacity = thirdPerson ? '0.9' : '0.6';
            }, 1500);
        }

        function updateCameraPerspective(delta) {
            const lerpSpeed = thirdPerson ? 5 : 10;
            cameraOffsetTarget.copy(thirdPerson ? thirdPersonCameraOffset : firstPersonCameraOffset);
            cameraCurrentOffset.lerp(cameraOffsetTarget, Math.min(1, delta * lerpSpeed));
            camera.position.copy(cameraCurrentOffset);
            if (thirdPerson) {
                camera.position.y = Math.max(camera.position.y, 0.2);
            }
        }

        function handleHealthRegen(delta) {
            if (!gameStarted || gamePaused) return;
            if (health >= maxHealth) return;
            const now = Date.now();
            if (now - lastDamageTime > healthRegenDelay) {
                health = Math.min(maxHealth, health + healthRegenRate * delta);
                updateHUD();
            }
        }

        function enableRadar(message) {
            if (radarEnabled) return;
            radarEnabled = true;
            if (radarCanvas) {
                radarCanvas.classList.add('active');
            }
            if (message) {
                showWaveAlert(message);
            }
        }

        function showWaveAlert(message) {
            const element = document.getElementById('wave-alert');
            element.textContent = message;
            element.style.display = 'block';
            element.style.opacity = '1';
            if (waveAlertTimeout) {
                clearTimeout(waveAlertTimeout);
            }
            waveAlertTimeout = setTimeout(() => {
                element.style.display = 'none';
            }, 2500);
        }

        function showMedkitAlert(message) {
            const element = document.getElementById('medkit-alert');
            element.textContent = message;
            element.style.display = 'block';
            element.style.opacity = '1';
            if (medkitAlertTimeout) {
                clearTimeout(medkitAlertTimeout);
            }
            medkitAlertTimeout = setTimeout(() => {
                element.style.display = 'none';
            }, 1800);
        }

        function spawnMedkit(originPosition) {
            if (medkits.length >= maxActiveMedkits) return;

            const medkitGeometry = new THREE.BoxGeometry(0.7, 0.3, 0.7);
            const medkitMaterial = new THREE.MeshStandardMaterial({
                color: 0x00ffcc,
                emissive: 0x00ffcc,
                emissiveIntensity: 0.6,
                metalness: 0.3,
                roughness: 0.2
            });
            const medkit = new THREE.Mesh(medkitGeometry, medkitMaterial);
            medkit.castShadow = true;
            medkit.receiveShadow = true;

            const spawnVector = originPosition ? originPosition.clone() : getSpawnPosition(6);
            if (originPosition) {
                spawnVector.x += (Math.random() - 0.5) * 4;
                spawnVector.z += (Math.random() - 0.5) * 4;
            }
            medkit.position.set(
                THREE.MathUtils.clamp(spawnVector.x, -48, 48),
                0.4,
                THREE.MathUtils.clamp(spawnVector.z, -48, 48)
            );

            const crossMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
            const crossVertical = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.6, 0.05), crossMaterial);
            const crossHorizontal = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.15, 0.05), crossMaterial);
            crossVertical.position.y = 0.25;
            crossHorizontal.position.y = 0.25;
            medkit.add(crossVertical);
            medkit.add(crossHorizontal);

            const glow = new THREE.PointLight(0x00ffcc, 1.2, 6);
            glow.position.y = 0.5;
            medkit.add(glow);
            medkit.userData.light = glow;

            medkit.userData.baseY = medkit.position.y;
            medkit.userData.floatOffset = Math.random() * Math.PI * 2;
            medkit.userData.rotationSpeed = 1 + Math.random() * 0.5;

            medkits.push(medkit);
            scene.add(medkit);
            lastMedkitSpawn = Date.now();
            showMedkitAlert('Medkit Deployed');
        }

        function updateMedkits(delta) {
            if (!gameStarted) return;

            const now = Date.now();
            if (!gamePaused && now - lastMedkitSpawn > medkitSpawnInterval && medkits.length < maxActiveMedkits) {
                spawnMedkit();
            }

            for (let i = medkits.length - 1; i >= 0; i--) {
                const medkit = medkits[i];
                medkit.rotation.y += medkit.userData.rotationSpeed * delta;
                medkit.position.y = medkit.userData.baseY + Math.sin(now * 0.002 + medkit.userData.floatOffset) * 0.15;

                const dx = medkit.position.x - yawObject.position.x;
                const dz = medkit.position.z - yawObject.position.z;
                if (Math.hypot(dx, dz) < 1.6) {
                    health = Math.min(maxHealth, health + medkitHealAmount);
                    score += 25;
                    showMedkitAlert(`+${medkitHealAmount} Health`);
                    scene.remove(medkit);
                    if (medkit.userData.light) {
                        medkit.remove(medkit.userData.light);
                    }
                    medkits.splice(i, 1);
                    lastMedkitSpawn = now;
                    updateHUD();
                }
            }
        }

        function startWave() {
            if (waveInProgress) return;
            waveInProgress = true;
            enemiesRemainingInWave = Math.max(5, 5 + Math.floor((wave - 1) * 2.5));
            const spawnCount = enemiesRemainingInWave;
            const spawnSpacing = Math.max(250, 700 - wave * 60);

            showWaveAlert(`Wave ${wave} Incoming`);
            updateHUD();

            for (let i = 0; i < spawnCount; i++) {
                const scheduleSpawn = () => {
                    if (!gameStarted || !waveInProgress) return;
                    if (gamePaused) {
                        setTimeout(scheduleSpawn, 200);
                        return;
                    }
                    createEnemy();
                };

                setTimeout(scheduleSpawn, i * spawnSpacing);
            }
        }

        function getSpawnPosition(minDistance = 8) {
            const candidate = new THREE.Vector3();
            const playerPosition = new THREE.Vector3(yawObject.position.x, 0, yawObject.position.z);
            for (let attempts = 0; attempts < 50; attempts++) {
                candidate.set((Math.random() - 0.5) * 90, 0, (Math.random() - 0.5) * 90);
                if (candidate.distanceTo(playerPosition) < minDistance) continue;

                let blocked = false;
                for (const obs of obstacles) {
                    if (!obs.userData.boundingBox) continue;
                    const box = obs.userData.boundingBox;
                    if (candidate.x > box.min.x - 1 && candidate.x < box.max.x + 1 &&
                        candidate.z > box.min.z - 1 && candidate.z < box.max.z + 1) {
                        blocked = true;
                        break;
                    }
                }
                if (!blocked) {
                    return candidate.clone();
                }
            }
            return candidate.clone();
        }

        function updateRadar() {
            if (!radarEnabled || !radarCtx) return;

            const width = radarCanvas.clientWidth;
            const height = radarCanvas.clientHeight;
            radarCtx.clearRect(0, 0, width, height);
            const baseLineWidth = 2 / radarDeviceRatio;

            const centerX = width / 2;
            const centerY = height / 2;
            const radius = width / 2 - 6;

            radarCtx.strokeStyle = 'rgba(0, 255, 200, 0.35)';
            radarCtx.lineWidth = baseLineWidth;
            radarCtx.beginPath();
            radarCtx.arc(centerX, centerY, radius, 0, Math.PI * 2);
            radarCtx.stroke();

            radarCtx.beginPath();
            radarCtx.moveTo(centerX - radius, centerY);
            radarCtx.lineTo(centerX + radius, centerY);
            radarCtx.moveTo(centerX, centerY - radius);
            radarCtx.lineTo(centerX, centerY + radius);
            radarCtx.stroke();

            const cosYaw = Math.cos(yaw);
            const sinYaw = Math.sin(yaw);
            const scale = radius / 60;

            enemies.forEach(enemy => {
                const dx = enemy.position.x - yawObject.position.x;
                const dz = enemy.position.z - yawObject.position.z;
                let rx = dx * cosYaw - dz * sinYaw;
                let ry = dx * sinYaw + dz * cosYaw;
                const distance = Math.sqrt(rx * rx + ry * ry);
                if (distance > 60) {
                    const ratio = 60 / distance;
                    rx *= ratio;
                    ry *= ratio;
                }
                const x = centerX + rx * scale;
                const y = centerY + ry * scale;
                radarCtx.fillStyle = enemy.userData.isArmed ? '#ff4f78' : '#ffb347';
                radarCtx.beginPath();
                radarCtx.arc(x, y, enemy.userData.isArmed ? 4 : 3, 0, Math.PI * 2);
                radarCtx.fill();
            });

            medkits.forEach(medkit => {
                const dx = medkit.position.x - yawObject.position.x;
                const dz = medkit.position.z - yawObject.position.z;
                let rx = dx * cosYaw - dz * sinYaw;
                let ry = dx * sinYaw + dz * cosYaw;
                const distance = Math.sqrt(rx * rx + ry * ry);
                if (distance > 60) {
                    const ratio = 60 / distance;
                    rx *= ratio;
                    ry *= ratio;
                }
                const x = centerX + rx * scale;
                const y = centerY + ry * scale;
                radarCtx.fillStyle = '#00ffcc';
                radarCtx.beginPath();
                radarCtx.arc(x, y, 3, 0, Math.PI * 2);
                radarCtx.fill();
            });

            radarCtx.strokeStyle = 'rgba(0, 255, 255, 0.4)';
            radarCtx.beginPath();
            radarCtx.moveTo(centerX, centerY);
            radarCtx.lineTo(centerX, centerY - radius + 12);
            radarCtx.stroke();
        }

        function updateEnvironment(delta, elapsedTime) {
            for (const animator of environmentAnimators) {
                animator(delta, elapsedTime);
            }
        }

        function animate() {
            requestAnimationFrame(animate);

            const delta = clock.getDelta();
            const elapsed = clock.elapsedTime;

            updatePlayer(delta);
            updateEnemies(delta);
            updateBullets(delta);
            updateParticles(delta);
            updateMedkits(delta);
            handleHealthRegen(delta);
            updateShooting();
            updateEnvironment(delta, elapsed);
            updateCameraPerspective(delta);
            updateRadar();

            renderer.render(scene, camera);
        }
        
        function onKeyDown(event) {
            const key = event.key.toLowerCase();
            keys[key] = true;

            if (event.key === 'Tab') {
                event.preventDefault();
                if (gameStarted) {
                    togglePerspective();
                }
                return;
            }

            if (key === 'r' && gameStarted) {
                reload();
            }

            if (event.key === 'Escape') {
                togglePause();
                event.preventDefault();
            }
        }

        function onKeyUp(event) {
            keys[event.key.toLowerCase()] = false;
        }
        
        function onMouseMove(event) {
            if (!gameStarted || gamePaused) return;
            
            const sensitivity = 0.002;
            
            yaw -= event.movementX * sensitivity;
            pitch -= event.movementY * sensitivity;
            
            // Limit pitch to prevent over-rotation
            pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, pitch));
            
            yawObject.rotation.y = yaw;
            pitchObject.rotation.x = pitch;
        }

        function onMouseDown(event) {
            if (!gameStarted || gamePaused) return;
            isMouseDown = true;
            shoot();
        }

        function onMouseUp(event) {
            isMouseDown = false;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);

            if (radarCanvas && radarCtx) {
                radarDeviceRatio = window.devicePixelRatio || 1;
                radarCanvas.width = radarCanvas.clientWidth * radarDeviceRatio;
                radarCanvas.height = radarCanvas.clientHeight * radarDeviceRatio;
                radarCtx.setTransform(radarDeviceRatio, 0, 0, radarDeviceRatio, 0, 0);
            }
        }
        
        function startGame() {
            document.getElementById('instructions').style.display = 'none';
            gameStarted = true;
            gamePaused = false;

            score = 0;
            kills = 0;
            wave = 1;
            enemiesRemainingInWave = 0;
            waveInProgress = false;
            waveCooldownActive = false;
            health = maxHealth;
            ammo = maxAmmo;
            lastDamageTime = Date.now();

            for (let i = medkits.length - 1; i >= 0; i--) {
                scene.remove(medkits[i]);
            }
            medkits.length = 0;
            lastMedkitSpawn = Date.now();
            updateHUD();
            updateModeIndicator();

            // Request pointer lock
            renderer.domElement.requestPointerLock =
                renderer.domElement.requestPointerLock ||
                renderer.domElement.mozRequestPointerLock ||
                renderer.domElement.webkitRequestPointerLock;

            renderer.domElement.requestPointerLock();

            document.addEventListener('pointerlockchange', onPointerLockChange);
            document.addEventListener('mozpointerlockchange', onPointerLockChange);
            document.addEventListener('webkitpointerlockchange', onPointerLockChange);

            startWave();
        }
        
        function onPointerLockChange() {
            const hasPointerLock = document.pointerLockElement === renderer.domElement ||
                                 document.mozPointerLockElement === renderer.domElement ||
                                 document.webkitPointerLockElement === renderer.domElement;
            
            if (!hasPointerLock && gameStarted && !gamePaused) {
                togglePause();
            }
        }
        
        // Initialize and start
        init();
        animate();
    </script>
</body>
</html>